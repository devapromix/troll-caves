from enum import Enum
from typing import NamedTuple

from common.utils import rand, roll
from mobs.mob import Mob


class DamageStatus(Enum):
    NORMAL = 0
    CRITICAL = 1
    EVADED = 2
    BLOCKED = 3
    ABSORBED = 4


def check_evasion(attacker, defender):
    accuracy = max(attacker.accuracy, 1)
    evasion = max(defender.evasion, 1)

    # Mob have at least ~5% (1/20) chance to evade strike and to success strike
    accuracy = accuracy if accuracy > evasion//20 else evasion//20
    evasion = evasion if evasion > accuracy//20 else accuracy//20
    return rand(1, evasion + accuracy) <= evasion


def block_chance(x):
    limit = 50
    # how much need blocking for chance = limit-1 %
    prelimit_blocking = 100
    return round(-(prelimit_blocking/x)+limit)


def check_blocking(defender):
    return defender.blocking > 0 and rand(1, 100) <= block_chance(defender.blocking)


class Damage:
    """
    Describe an action of damage to a mob to another.
    """
    attacker: Mob
    defender: Mob
    status: DamageStatus
    value: int
    """
    Damage value after calculating armor, supress e.t.c
    """
    raw_value: int
    """
    Damage value generated by attacker, without armor etc
    """

    def __int__(self):
        return self.value

    def __str__(self):
        return '%s: %d' % (self.status, self.value)

    @staticmethod
    def calculate(attacker: Mob, defender: Mob):
        damage = Damage()
        damage.attacker = attacker
        damage.defender = defender
        damage.raw_value = roll(*attacker.dice) + attacker.damage_bonus
        damage.value = 0

        if check_evasion(attacker, defender):
            damage.status = DamageStatus.EVADED
            return damage

        if check_blocking(defender):
            damage.status = DamageStatus.BLOCKED
            return damage

        damage.value = defender.calc_damage(damage.raw_value)
        if damage.value > 0:
            if rand(1, 20) == 1:
                damage.status = DamageStatus.CRITICAL
                damage.value *= 2
            else:
                damage.status = DamageStatus.NORMAL
        else:
            damage.status = DamageStatus.ABSORBED
        return damage
